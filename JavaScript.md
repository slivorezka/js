JavaScript
--
* `ECMAScript` – стандарт, а `JavaScript` – найпопулярніша реалізація цього стандарту
* `ES` — це просто скорочення для `ECMAScript`
* Кожне видання `ECMAScript` отримує абревіатуру `ES` з наступним номером
* Усього існує 8 версій `ECMAScript`
* `ES1` — було випущено у червні 1997 року
* `ES2` — у червні 1998 року
* `ES3` — у грудні 1999 року
* `ES4` — так і не було прийнято
* `ES5` — у грудні 2009 року
* `ES6` / `ES2015` — у червні 2015 року
  * `destructuring assignment`
  * `arrow function`
  * `let` / `const`
* `ES7` / `ES2016` — у червні 2016 року
  * `**`
  * `Array.prototype.includes`
* `ES8` / `ES2017` — у червні 2016 року
  * `async` /` await`
* `ES9` / `ES2018` — у червні 2016 року
  * `async` /` await` 

V8 Engine
--
* Це високопродуктивний рушій `JavaScript` і `WebAssembly` від `Google` з відкритим вихідним кодом, написаним на `C++`
* Використовується в `Node.js`
* `V8` транслює `JS`-код у більш ефективний машинний код, не використовуючи інтерпретатор

Методи HTTP запита
--
* GET— вимагає представлення ресурсу. Запити з цього методу можуть лише витягувати дані.
* HEAD — просить ресурс так само, як і метод GET, але без тіла відповіді.
* POST — використовується для надсилання сутностей до певного ресурсу.
* PUT — замінює всі поточні уявлення ресурсу даними запиту.
* DELETE — видаляє вказаний ресурс.
* CONNECT — встановлює "тунель" до сервера, визначеного ресурсом.
* OPTIONS — використовується для опису параметрів з'єднання з ресурсом.
* TRACE — виконує виклик тестового повідомлення, що повертається з ресурсу.
* PATCH — використовується для часткової зміни ресурсу.

Версії HTTP запита
--
* HTTP/1.0 [1996]
  * Тільки якщо указано в заголовку `keep-alive`
  * Для завантаження кожного ресурсу встановлювалось нове TCP/IP з'єднання
* HTTP/1.1 [2015]
  * Додані методи: PUT, DELETE, OPTIONS, TRACE, CONNECT, PATCH
  * Додано за замовчуванням `keep-alive`, який дозволив завантажувати безліч ресурсів у межах одного з'єднання. Однак, ресурси завантажуються послідовно `waterfall`: не можна отримати наступний ресурс, доки отримано попередній.
* HTTP/2 [2015]
  * Застосування бінарного протоколу, що оперує передачею бінарних кадрів. Кожен кадр має заголовок з інформацією про тип, розмір, опції та ідентифікаторі потоку. Кадри з типом DATA використовуються для передачі даних, HEADERS — HTTP-заголовків, RST_STREAM — для дострокового переривання відправлення даних;
  * Мультиплексування і розпаралелювання потоків в рамках одного TCP-з'єднання. Пакети різних потоків змішуються і, на відміну від конвеєрної передачі HTTP/1.1, не очікують закінчення відправлення запиту. Підтримка ефективної двобічної передачі даних. Можливість мультиплексування при зверненні до різних хостів, що дозволяє додатково прискорити одночасне завантаження вебконтенту з різних сайтів (у SPDY мультиплексування підтримується тільки для одного хоста);
  * Можливість встановлення пріоритетів і залежностей для потоків, що дозволяє виділити найважливіші потоки, які потрібно виконати в першу чергу, а також визначити залежність одного потоку від іншого;
  * Стиснення HTTP-заголовків. У тому числі підтримується усунення дублікатів заголовків і Cookie, повторюваних для серії запитів до одного сайту. Допускається визначення окремих заголовків що не підлягають стисненню;
  * Низька чутливість до затримок;
  * Засоби для узгодження протоколу між клієнтом і сервером, що дозволяють вибрати HTTP/1.1, HTTP/2.0 і інші протоколи: сервер надає список підтримуваних протоколів, які може вибрати клієнт. Для шифрованих з'єднань параметри TLS узгоджуються за допомогою протоколу ALPN, при якому клієнт повідомляє список підтримуваних опцій, а сервер вибирає найоптимальніший для себе варіант;
  * Забезпечення високого рівня сумісності з HTTP/1.1: збережені заголовки, схема URI, коди стану і методи (GET, POST тощо). Забезпечена можливість створення проксі для доступу клієнтів HTTP/1.1 до серверів HTTP/2.0;
  * Можливість встановлення шифрованих (HTTPS) і не шифрованих з'єднань (HTTP). Шифрування здійснюється з використанням TLS 1.3 або новішої версії. Незважаючи на те, що специфікація дозволяє створення нешифрованих сполучень, розробники Firefox і Google Chrome мають намір забезпечити роботу HTTP/2.0 тільки поверх TLS;
  * Підтримка технології Server push для передачі даних від сервера до клієнта (наприклад, коли сервер вважає, що після певного запиту обов'язково будуть затребувані інші дані, він може відправити ці дані не чекаючи фактичного запиту);
  * Підтримка HTTP/2.0 на час пропозиції стандарту вже реалізована в браузерах
* HTTP/3 [2018]

Відповіді стану HTTP
--
  * 1xx – інформаційні. Тимчасові коди, пов’язані з передачею даних, інформують про продовження прийнятого запиту.
  * 2xx – успішні. Запит отримано та опрацьовано.
  * 3xx – перенаправлення (редирект). Для виконання запиту необхідні ще дії.
  * 4xx – клієнтські помилки. Запит не вдався через помилки клієнта.
  * 5xx – серверні помилки. У цьому класі сервер завжди повідомляє про причини необробленого запиту. Клієнтської помилки в цьому випадку немає.
  * 200 OK – Все добре
    * 201 Created – «Створено». Запит виконаний і ресурс створений.
    *  202 Accepted – «Прийнято». Запит прийнятий, але не оброблений. Чи не підтримується – немає способу за допомогою HTTP відправити відповідь пізніше.
    *  203 Non-Authoritative Information – «Інформація не авторитетна». Повернута інформація надана з іншого джерела, а не від стартового сервера.
    *  204 No Content – «Немає вмісту». Немає вмісту для відповіді. Заголовки відповіді при цьому надсилаються.
    *  205 Reset Content – «Скинути вміст». Повідомлення, що запит оброблений, і необхідно відправити відображення документа цього запиту.
    *  206 Partial Content – «Частковий вміст». Використовується для окремого завантаження в кілька потоків при відправці заголовка діапазону.
  * 301 Moved Permanently – Редирект на нову сторінку на постійній основі, тобто сторінка переміщена на новий URL назавжди.
    * 302 Found – «Знайдено». Тимчасово змінено запитуваний ресурс. У майбутньому зміни в URI, можливо, будуть доступні.
    *  303 See Other – «Перегляд інших ресурсів». Напрямок для отримання запитуваного ресурсу в інший URI із запитом GET.
    *  304 Not Modified – «Не модифіковано». Запитаний ресурс не змінений. Можна використовувати кешовану версію відповіді далі.
    *  305 Use Proxy – «Використовувати проксі». Запитуваний ресурс має доступ через проксі.
    *  306 Switch Proxy – «Більше не використовувати».
    *  307 Temporary Redirect – «Тимчасове перенаправлення». Відправлено для отримання запитаного ресурсу на інший URL-адресу за допомогою методу попереднього запиту.
    *  308 Permanent Redirect – «Перенаправлення на постійній основі». Постійне перебування ресурсу в іншому URI, який знаходиться в заголовку.
  * 404 Not Found – Сторінка не знайдена
    * 400 Bad Request – «Поганий запит». Некоректний синтаксис не дає серверу обробити запит.
    *  401 Unauthorized – «Неавторизовано». Необхідна аутентифікація для отримання відповіді.
    *  402 Required – «Необхідна оплата». Код використання в майбутньому.
    *  403 Forbidden – «Заборонено». Сервер відмовляє у відповіді, так як у клієнта немає прав доступу до змісту ресурсу.
    *  404 Not Found – «Не знайдений». Сервер не може знайти запитуваний ресурс. Через частоти появи в інтернеті код відповіді є найвідомішим.
    *  405 Method Not Allowed – «Метод не дозволено». Метод, відомий серверу, деактивовано і неможливо його використовувати.
    *  406 Not Acceptable – Не знайдено контент із зазначеними критеріями від user agent.
    *  407 Proxy Authentication Required – Аналогічно коду 401. Тільки в цьому коді потрібно аутентифікація для проксі сервера.
    *  408 Request Timeout – Відповідь коду може прийти без попереднього запиту, тому сервер відключає невикористовуване з’єднання.
    *  409 Conflict – Запит в конфлікті з реальним станом сервера.
    *  410 Gone – Контент, який був запитаний, видалено з сервера.
    *  411 Length Required – Серверу потрібен вказаний заголовок Content-Length, тому запит відхилений.
    *  412 Precondition Failed – У заголовках вказані умови, які серверу неможливо виконати. 
  * 500 Internal Server Error — Внутрішня помилка сервера
    * 501 Not Implemented – «Не виконано». Метод запиту не обробляється і не підтримується сервером.
    *  502 Bad Gateway – «Поганий шлюз». Під час роботи в якості шлюзу сервер отримав недійсну відповідь.
    *  503 Service Unavailable – «Сервіс недоступний». Сервер не готовий обробляти запит, причиною є відключення сервера або його перевантаженість. Сторінка повинна відправляти пояснення проблеми разом з відповіддю.
    *  504 Gateway Timeout – Сервер працює в вигляді шлюзу, не отримуючи своєчасно відповідь.
    *  505 HTTP Version Not Supported – «HTTP-версія не підтримується». Не підтримується HTTP-версія, яка використовується в запиті.

CORS
--
* Cross-Origin Resource Sharing — Спільне використання ресурсів між різними джерелами - це система, що складається з відправки HTTP заголовків, які визначають: заблокувати або виконати запит до обмеженого ресурсу на веб-сторінці з іншого домену, відмінного від домену походження запитуваного ресурсу.

HTTP Cookie
--
* HTTP cookie (web cookie, cookie браузера) - це невеликий фрагмент даних, який сервер надсилає браузеру. Браузер може зберегти цей фрагмент у себе та відправляти на сервер з кожним наступним запитом. Це, зокрема, дозволяє дізнатися, чи з одного браузера надійшло кілька запитів (наприклад, для автентифікації користувача). За допомогою кук можна зберегти будь-яку інформацію про стан.
  * `Session cookie` — Такі `cookie` видаляються під час закриття клієнта, тобто існують лише протягом поточного сеансу, оскільки атрибути `Expires` або `Max-Age` для нього не задаються.
  * `Permanent cookies` — Видаляються не із закриттям клієнта, а при настанні певної дати (атрибут `Expires`) або після певного інтервалу часу (атрибут `Max-Age`).
  * `Secure` / `HttpOnly` — Куки надсилаються на сервер лише тоді, коли запит надсилається протоколом `SSL` і `HTTPS`.
  * У технічному сенсі `cookies` – це невеликі за обсягом текстові файли. Максимально допустимий розмір одного такого файлу - `4096` байт.

REST
--
* REST [Representational State Transfer] — це архітектурний стиль мережевої системи і виступає для передачі репрезентативного стану. Це сам не стандарт, але використовує такі стандарти, як `HTTP`, `URL`, `XML` і т.д. `REST` є архітектурним стилем, наразі `SOAP` є протоколом.

"use strict"
--
* Директива `use strict` була новою в `ECMAScript` версії 5.
  * Це не інструкція, а буквальний вираз, що ігнорується більш ранніми версіями `JavaScript`
  * Ціль `use strict` - вказати, що код має виконуватись в "строгому режимі".
  * В строгому режимі не можна, наприклад, використовувати не оголошені змінні, команди як `eval()` чи `this.caller`
  * У цьому режимі попередження `warning` стають помилками `error`

Immutable
--
* `Immutable` — Незмінне значення – це значення, зміст якого не можна змінити.
* Примітивні значення незмінні (`string`, `number`, `bigint`, `boolean`, `undefined`, `symbol`, `null`) — коли примітивне значення створено, його неможливо змінити.
* Значення `objects` і `arrays` є змінними за замовчуванням — їхні властивості та елементи можна змінювати.
  * `let array = [1, 2, 3, 4, 5];`
  * `ImmutableArray = array.slice(0, -1);`
  * `array.push(6)` / `ImmutableArray = [...array, 6];`
  * `array.shift()` / `let = item; [item, ...ImmutableArray] = array;`
  * `array.unshift(5)` / `ImmutableArray = [5, ...array];`
  * `array.reverse()` / `ImmutableArray = [...array].reverse();`

XSS `Cross-Site Scripting`
--
* Один із різновидів атак на веб системи, що передбачає впровадження шкідливого коду на певну сторінку сайту та взаємодію цього коду з віддаленим сервером зловмисників при відкритті сторінки користувачем
* Основна мета `XSS`– крадіжка `cookies` користувачів за допомогою вбудованого на сервері скрипту з подальшою вибіркою необхідних даних та використанням їх для наступних атак та зломів
* 

FAQ
--
* Які існують типи даних у JS?
  * Всього в JavaScript існує 8 типів:
    * `number`
    * `string`
    * `boolean`
    * `bigint`
    * `null`
    * `undefined`
    * `symbol`
    * `object`
* Які значення в JS є хибними?
  * `0`
  * `null`
  * `undefined`
  * `NaN`
  * `false`
* Як перевірити, чи об’єкт є масивом?
  * Сучасний метод `array.isArray()` (був введений у стандарті ECMAScript 5)
  * Легасі `[1, 2].constructor.name === 'Array'`
  * Легасі `Object.prototype.toString.call([1, 2]) === '[object Array]'`
* Як перевірити, чи число є скінченним?
  * Глобальна `isFinite()` функція визначає, чи є передане значення кінцевим числом
* Як перевірити, що змінна рівна `NaN`? 
  * Функція `isNaN()` визначає чи є змінна нечисловим значенням `NaN` чи ні
* Чим відрізняється поведінка `isNaN()` та `Number.isNaN()`?
  * На відміну від глобальної функції `isNaN()`, `Number.isNaN()` немає проблеми примусового перетворення параметра в число. Це означає, що він безпечно передавати значення, які зазвичай перетворюються на `NaN`, але насправді `NaN` не є.
* `JavaScript Hoisting`
  * `Hoisting` це процес, у якому інтерпретатор переміщує оголошення функцій, змінних або класів у верхню частину їхньої області видимості перед виконанням коду
* Порівняйте ключові слова `var`, `let`, `const`
  * `var`  
    * Значення може бути визначено пізніше
    * Значення може бути перевизначено в майбутньому
    * Підтримує повторне оголошення. Кількість оголошень не обмежена
    * Ігнорує блокову область видимості. Змінні, оголошені в такий спосіб будуть видно поза блоку
    * Підтримує `hoisting`
  * `let`
    * Значення може бути визначено пізніше
    * Значення може бути перевизначено в майбутньому
    * Не підтримують повторне оголошення
    * Дотримується блокової області видимості
    * Не підтримують `hoisting`
  * `const`
    * Значення має бути визначено під час оголошення змінної (відразу)
    * Значення у констант не перевизначаються
    * Не підтримують повторне оголошення
    * Дотримується блокової області видимості
    * Не підтримують `hoisting`
* Що таке область видимості?
  * Це частина коду, де змінні та функції можуть бути видимими та доступними для використання. Вона визначає, чи імена змінних і функцій є дійсними та можуть бути використані. У кожній області видимості певні змінні та функції можуть бути видимими, а інші можуть бути недоступними або мати інші значення
  * У JavaScript існує кілька типів областей видимості:
    * Глобальна область видимості
      * Вона охоплює всю програму. Змінні та функції, оголошені в глобальній області видимості, можуть бути доступні в будь-якому місці програми.
    * Функціональна область видимості
      * Кожна функція в `JavaScript` має власну область видимості. Змінні, оголошені всередині функції, видно тільки всередині цієї функції, і вони не можуть бути доступні ззовні
    * Блокова область видимості
      * Запроваджено в `ECMAScript 6` за допомогою ключових слів `let` і `const`. Блокова область видимості обмежує видимість змінних тільки всередині блоку коду, який зазвичай визначається фігурними дужками `{}`. Змінні, оголошені всередині блоку, видно тільки всередині цього блоку і недоступні за його межами
* Що таке деструктуризація?
  * Деструктуризація об'єкта `JS` (ECMAScript 2015 `ES6`) – це синтаксична зручність, що полегшує вилучення даних із масивів або об'єктів, даючи змогу прямо “розпаковувати” їхні значення у змінні. Це дає змогу писати компактніший і виразніший код, зменшуючи необхідність вручну витягувати дані зі структур даних
* Для чого призначені методи setTimeout і setInterval?
  * `setTimeout` — дозволяє нам запускати функцію один раз через певний інтервал часу
    * `clearTimeout(id)` — використовувати для скасування виконання `setTimeout`
  * `setInterval` — дозволяє нам запускати функцію багаторазово, починаючи через певний інтервал часу, а потім постійно повторюючи у цьому інтервалі
    * `clearInterval(id)` — використовувати для скасування виконання `setInterval`
* Порівняйте підходи роботи з асинхронним кодом: `сallbacks` / `promises` / `async / await`
  * `сallback` — функція, що передається аргументом в іншу функцію для її виконання після завершення виконання певного коду. Така собі функція зворотного виклику. Відповідно функції, які використовуються для продовження роботи коду після виконання асинхронної операції є асинхронними колбеками
  * `promise` — це спеціальний об'єкт `JavaScript`, що використовується для написання та виконання асинхронного коду
  * `async / await` — Слово `async` додане до функції робить її асинхронною повертаючи результат у вигляді об'єкта `promise`, лишається зазначити через `await` на завершення якої частини коду ми хочемо почекати. По суті це синтаксичний цукор над `promise`.
* `Map` і `Set`
  * `Map` — це колекція ключ/значення, як і `Object`. Але основна відмінність полягає в тому, що `Map` дозволяє мати ключі будь-якого типу.
    * Відмінності від звичайного об’єкта `Object`:
      * Що завгодно може бути ключем, в тому числі й об'єкти.
      * Є додаткові методи, властивість `size`.
  * `Set` – це особливий тип колекції: "множина" значень (без ключів), де кожне значення може з’являтися тільки раз.
* Що означає глибока `deep` та поверхнева `shallow` копія об'єкта?
  * `shallow`
    * `Object.assign() / {...Object}` — Поверхнева копія скопіює лише `top-level` властивості, але вкладені об'єкти будуть використовуватися як оригіналом, так і копією.
  * `deep`
    * `JSON.parse(JSON.stringify(Object)) / structuredClone()`
    * На жаль, цей метод не можна використовувати для копіювання методів об'єкта, написаних користувачем вручну
    * Не серіалізуються: примітив `undefined`, функція, `symbol` - при виклику JSON.stringify отримуємо `undefined`
* Яка різниця між декларацією функції `function declaration` та функціональним виразом `function expression`?
  * `Function Declaration`
    * Це функція яка має назву
  * `Function Expression`
    * Це функція яка присвоєна змінній
    * Може бути анонімною функцією
* Що таке анонімна функція?
  * Кожна функція `JavaScript` — це об'єкт [`Function`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
  * Функції бувають 
    * `Function Declaration`/ `Regular Function` — `function hello() { }`
    * `Function Expression` — `const hello = function() { }`
    * `Named Function Expression` — `const hello = function hello() { }`
    * `Arrow Function` — `const hello = () => { }`
    * `Auto Invoke Function` — `(function() { } ())` / `(() => { })()`
    * `Generator Function` — `function* generator(i) { yield i; yield i + 10; }`
* В чому полягають відмінності стрілкових функцій `arrow function` від звичайних?
  * Не може використовувати аргументи локальну змінну `arguments`, як у звичайних функціях `function hello() { console.log(arguments) }`
  * Не може використовувати як конструктори `constructor`
  * Не може можу бути типу `Function Declaration`
  * Не може використовуватись до того як була обʼявлена (не підтримують `hoisting`)
* `IIFE` (Immediately Invoked Function Expression)?
  * `IIFE` — це функція яка виконується відразу ж після того, як вона була визначена
  * Змінна, якій присвоєно `IIFE`, зберігає в собі результат виконання функцій, але не саму функцію
* Що таке `hoisting`?
  * `hoisting`, тобто спливання, підняття — це механізм, при якому змінні та оголошення функції піднімаються вгору по своїй області видимості перед виконанням коду
  * Дозволяє нам використовувати функції перед їх оголошенням у коді
* Що таке замикання `closure`?
  * `Сlosure` – поєднання функції, зчепленої вкупі з (замкненої на) посиланням на стан, що її оточує (лексичне оточення). Інакше кажучи, замикання надає з внутрішньої функції доступ до області видимості зовнішньої функції
  * У `JavaScript` замикання породжуються щоразу, коли створюється функція, під час її створення
* Що означає ключове слово `this`?
  * Для доступу до інформації всередині об’єкта метод може використовувати ключове слово `this`
  * Значення `this` визначається під час виконання.
  * В такому випадку `this` є `undefined` в режимі `use strict`
  * В `use strict` режимі `this` є `undefined`, або `window` не в `use strict` режимі
  * Стрілкові функції `Arrow Function` не мають власного `this`, a якщо викликати `this` в середині `Arrow Function` то буде виклик зовнішнього `this`
* Методи функцій `bind` / `call` / `apply`
  * Метод `bind` створює нову функцію, яка при виклику встановлює в якості контексту виконання цього наданого значення
  * Метод `call` викликає функцію із вказаним значенням `this` та індивідуально наданими аргументами
  * Метод `apply` викликає функцію із вказаним значенням `this` і аргументами, наданими у вигляді масиву
* Що таке `DOM`?
  * `DOM` (`Document Object Model`) — це програмний інтерфейс `API`, який дає змогу розробникам отримувати доступ до структури та вмісту `HTML`
  * Деякі з ключових методів включають `DOM`
    * `getElementById(id)` — отримує елемент за його ідентифікатором
    * `getElementsByClassName(className)` — повертає колекцію елементів з певним класом
    * `getElementsByTagName(tagName)` — повертає колекцію елементів з певним тегом
    * `querySelector(selector)` — повертає перший елемент, що відповідає заданому селектору `CSS`
    * `querySelectorAll(selector)` — повертає всі елементи, що відповідають заданому селектору `CSS`
* Підключення скрипту `async` / `defer` в `HTML`
  * Атрибут `defer` повідомляє браузеру, що йому не треба чекати на скрипт. Замість цього браузер продовжить обробляти `HTML`, будувати `DOM`. Скрипт завантажується у фоновому режимі, а потім запускається, коли `DOM` повністю побудовано
    * Скрипти з `defer` ніколи не блокують сторінку
    * Скрипти з `defer` завжди виконуються, коли `DOM` готовий, але перед подією `DOMContentLoaded`
    * Відкладені скрипти зберігають відносний порядок, як і звичайні скрипти
    * Атрибут `defer` призначений лише для зовнішніх скриптів і ігнорується, якщо тег `<script>` не має `src`
  * Атрибут `async` дещо схожий на `defer`. Він також робить скрипт не блокуючим. Але він має важливі відмінності в поведінці
    * Браузер не блокує `async` скрипти
    * Інші скрипти не чекають `async` скриптів, а `async` скрипти не чекають їх
    * `DOMContentLoaded` та асинхронні скрипти не чекають один одного
    * Скрипти `async` завантажуються у фоновому режимі та запускаються по готовності
    * Атрибут `async` призначений лише для зовнішніх скриптів і ігнорується, якщо тег `<script>` не має `src`
* Яка різниця між властивостями `innerHTML` та `innerText`?
  * `innerHTML` — повертає текстовий вміст елемента, включаючи всі пробіли та внутрішні теги `HTML`
  * `innerText` повертає — лише текстовий вміст елемента та всіх його дочірніх елементів, без прихованих текстових інтервалів і тегів `CSS`, за винятком елементів `<script>` та `<style>`
* Бульбашковий механізм (спливання та занурення) `bubbles` / `capturing`
  * Спливання` bubbles`
    * Коли подія відбувається на елементі, спочатку запускаються обробники на ньому, потім на його батькові, потім на інших предках і так до самого верху
    * Найбільш глибоко вкладений елемент, що викликав подію, називається цільовим елементом, та доступний як `event.target`
    * `event.stopPropagation()` / `event.stopImmediatePropagation()` — зупиняє спливання
  * Занурення `capturing`
    * `element.addEventListener(..., { capture: true })` / `element.addEventListener(..., true)`
    * Фаза занурення `capturing phase` – подія "спускається" до елемента
    * Фаза цілі `target phase` – подія досягає цільового елемента
    * Фаза спливання `bubbling phase` – подія "спливає" від елемента вгору
* `sessionStorage`
  * `sessionStorage` дозволяє отримати доступ до об'єкта [`Storage`](https://developer.mozilla.org/en-US/docs/Web/API/Storage) поточної сесії
  * `sessionStorage` відчищаються в момент закінчення сесії поточної сторінки
  * Дані привʼязані до сайту Домен / Порт / Протокол
* `localStorage`
  * `localStorage` дозволяє отримати доступ до [`Storage`](https://developer.mozilla.org/en-US/docs/Web/API/Storage)  об'єкта зберігання
  * Не обмежені за часом зберігання та можуть бути видалені лише за допомогою `JavaScript`
  * Ключі та значення завжди `string`, так само як і об'єкти, ціло численні ключі будуть автоматично перетворені в `string`
  * Ліміт становить `5 Мб` і залежить від браузера
  * Спільний доступ з усіх вкладок і вікон для того самого сайту
  * Дані привʼязані до сайту Домен / Порт / Протокол
* `Event loop`
  * Потік виконання в `JavaScript` працює для розрахунку циклу подій `event loop`, який відповідає за виконання коду, збірку й обробку подій і виконання підзадач
  * Макрозадачі `Macrotasks` — `setTimeout`, `setImmediate`, `setInterval`, `UI`
  * Мікрозадачі `Microtasks` — `Promise`, `process.nextTick`, `queueMicrotask`, і на фронті ми маємо наглядача за DOM елементами — `MutationObserver`
  * Мікрозадачі мають пріоритет перед макрозадачами
  * Одразу після кожного макрозавдання, рушій виконує всі завдання з черги мікрозавдань перед тим як виконати якесь макрозавдання чи рендеринг, чи виконати щось іще
  * Жодні `UI` або мережеві події не обробляються між мікрозавданнями — мікрозавдання виконуються негайно одне за одним
  * Також обробники промісів виконуються в черзі мікрозавдань.
  * `FIFO` (First In First Out) — тобто остання подія буде оброблена в останню чергу
  * `process.nextTick()`
  * `queueMicrotask()`
  * `setImmediate()`
* `Temporal Dead Zone` / `TDZ`
  * `TDZ` — термін для опису стану, коли змінні недоступні. Вони в області видимості, але не оголошені. Тобто це проміжок часу між створенням зв'язування змінної `let` або `const` та її оголошенням (в межах її області)
  * Якщо `var` викликана до оголошення, то ця змінна матиме `undefined`
  * Якщо `let` або `const` викликана до оголошення, то ця цей код поверне помилку `ReferenceError: foo is not defined`
* `boxing-unboxing (Wrapper Objects)`
  * Не працює з `null` і `undefined`
  * `boxing-unboxing` — це процес тимчасового перетворення типу `string` в `object`, щоб можна було скористатися методом `toUpperCase`
* Що таке прототип `prototype`?
  * Може приймати значення `null` або мати посилання на інший `object`
  * `Object.getPrototypeOf` / `Object.setPrototypeOf` — це є `getter` / `setter`
  * Легасі `__proto__` — це є `getter` / `setter` для `[[Prototype]]`
  * Цикл `for..in` ітерує як і власні властивості, так і по успадковані
  * Методи `map` / `each` отримують з пар `key` / `value` тільки власні властивості об'єкта
* Що таке кортежі `tuples` і записи `records`?
  * `tuples` - це глибоко незмінні структури даних, подібні масивам. По суті, це складні примітивні типи, ідентифіковані модифікатором `#` перед синтаксисом нормального масиву `const foo = #[1, 2, 3];` / `const foo = Tulpe.from([1, 2, 3]);`
    * Не повинно бути` holes` з невстановленими значеннями. Наприклад, `#[1, , ,4]` недійсний
    * Повинні мати лише примітиви, інші кортежі `tuples` чи записи `records`
    * Оскільки кортежі `tuples` є примітивами, їх можна порівняти за значенням з іншими кортежами `const foo = #[1, 2, 3]; foo === #[1, 2, 3];`
    * Якщо кортеж `tuples` має одне значення, його можна зрівнювати не строгим порівнянням `==`, наприклад: `const foo = #[123]; foo == #[123]; foo == 123; foo == '123'`
  * `records` - це глибоко незмінні структури даних подібні об'єктам `const foo = #{ foo: 123 }` / `const foo = new Record({ foo: 123 });`
    * Повинні мати лише примітиви, інші кортежі `tuples`, записи `records` чи примітиви
    * Оскільки записи `records` є примітивами, їх можна порівняти за значенням з іншими записами `const foo = #{ 1, 2, 3 }; foo === #{ 1, 2, 3 };`
* Які відмінності в поведінці `ES5` функції-конструктора та `ES2015` класу?
  * Клас — це синтаксичний цукор над функцією конструктора
  * Під час створення екземпляра класу, методи описані в ньому потрапляють у прототип, а методи описані всередині функції конструктора потраплять у сам екземпляр
  * Для того, щоб методи, описані всередині функції конструктора, потрапили в прототип, їх потрібно окремо туди додати
* Що таке приведення (перетворення) типів у `JS`?
  * Приведення типів `Coercion` це процес перетворення значення з одного примітивного типу в інший
  * Наприклад, `JavaScript` може перетворити число в рядок, або не-логічне (не-булеве) значення в логічне
* Що таке `Garbage Collector`?
  * Управління пам'яттю `JavaScript` виконується автоматично і непомітно для нас
  * Основною концепцією управління пам'яттю `JavaScript` є принцип досяжності
  * Досяжними вважаються ті, що доступні або використовуються. Вони гарантовано перебувають у пам'яті
  * Щоб об'єкт став не досяжним, потрібно видалити на нього всі посилання, після того, як він стане не досяжним, він піти з пам'яті
* Опишіть призначення і принципи роботи з колекціями `WeakMap` і `WeakSet`
  * `WeakMap`
    * Перша відмінність між `Map` та `WeakMap` – це те, що ключі повинні бути об'єктами, а не примітивними значеннями
    * `WeakMap` – це подібна до Map колекція, яка дозволяє використовувати лише об'єкти, як ключі і видаляє їх разом з пов'язаним значенням, коли вони стануть недоступними іншим засобам
  * `WeakSet`
    * Перша відмінність між `Set` та `WeakSet` – це те, що ключі повинні бути об'єктами, а не примітивними значеннями
    * `WeakSet` – це подібна до `Set` колекції, яка зберігає тільки об'єкти та видаляє їх після того, як вони стануть недоступними іншим засобам
  * Їх основна перевага полягає у тому, що вони мають слабке посилання на об'єкти, тому вони можуть бути легко видаленими збирачем сміття
  * Це досягається внаслідок відсутності підтримки `clear`, `size`, `keys`, `values`
  * WeakMap та WeakSet використовуються як "вторинні" структури даних, на додаток до "первинного" сховища об'єктів
  * Після того, як об'єкт видаляється з первинного сховища, якщо він виявляється лише як ключ `WeakMap` або в `WeakSet`, він буде очищений автоматично
* Чим відрізняється `Observable` від `Promise`?
  * `Observable`
    * Більш гнучка система керування подіями й потоками даних
    * Можливість створювати складні послідовності подій
    * Легше взаємодіяти з даними з різних джерел
  * `Promise`
    * Простіший та більш інтуїтивний синтаксис
    * Зручний для обробки одиничних асинхронних операцій
* `Web workers`
  * `new Worker('worker.js')` — Після створення web-worker він працює в окремому потоці, незалежному від основного потоку браузера, виконуючи будь-який код у наданому йому скрипті
  * Дані між `Workers` та основним потоком JavaScript передаються за допомогою двох додаткових функцій у коді `JavaScript` функція `postMessage()` для посилання даних
  * Ізольоване глобальне середовище для потоку web worker, окреме від середовища браузера
  * Обмін даними через основний потік та потік `web worker` відбувається тільки через виклик `postMessage()`, причому дані передаються за значенням
  * Можливі випадки застосування `web worker`
    * Попереднє завантаження та / або кешування даних для подальшого використання
    * Опитування та обробка даних із веб-служб
    * Обробка та показ великих наборів даних `think genomics`
    * Обчислення, пов'язані з рухами в грі
    * Обробка та фільтрація зображень
    * Обробка текстових даних (синтаксис коду, перевірка правопису, кількість слів)
* Що таке `ArrayBuffer`? У чому різниця між `Uint32Array` і `Float32Array`?
  * `ArrayBuffer` використовується для роботи з бінарними даними, не є масивом
  * Він має фіксовану довжину, що не може бути збільшена чи зменшена
  * Він займає саме стільки місця, скільки виділено при створенні
  * Для доступу до окремих байтів нам знадобиться окремий об’єкт представлення, `buffer[index]` не спрацює
  * Він являти собою посилання на потік "сирих" подвійних даних, однак працювати з ними прямої можливості не дає
  * Для роботи з `ArrayBuffer` нам потрібен спеціальний об'єкт "представлення"
    * `Uint8Array` – представляє кожен байт в `ArrayBuffer` окремому числом з областю значень від 0 до 255 (байт складається з 8 біт, тому тільки такі значення можливі). Такі числа називаються "8-бітові беззнакові цілі числа"
    * `Uint16Array` – представляє кожні 2 байти цілим числом з областю значень від 0 до 65535. Має назву "16-бітові беззнакові цілі числа"
    * `Uint32Array` – представляє кожні 4 байти цілим числом з областю значень від 0 до 4294967295. Має назву "32-бітові беззнакові цілі числа"
    * `Float64Array` – представляє кожні 8 байтів числом з плаваючою комою з областю значень від 5.0x10-324 до 1.8x10308
    * Отже, бінарні дані в 16 байтному `ArrayBuffer` можна представити як 16 "коротких чисел" або 8 більших чисел (2 байти кожне), або 4 ще більших (4 байти кожне), або 2 числа з плаваючою комою високої точності (8 байти кожне)
* Що таке `descriptor`?
  * Дескриптор `descriptor` – об'єкт, який описує властивості поведінки
    * `value` – значення властивості, за замовчанням `undefined`
      *  Щоб уникнути конфлікту, заборонено одночасно показувати значення `value` та функції `get` / `set`
      * Також заборонено і не має сенсу вказувати можливість запису при наявності функцій `get` / `set`
    * `writable` – значення властивості можна змінювати, якщо `true`. За замовчанням `false`.
    * `configurable` – якщо true, це властивість можна видалити, а також змінити його надалі за допомогою нових викликів `defineProperty`. За замовчанням `false`.
    * `enumerable` – якщо істина, це властивість переглядається в циклі `for..in` і методі `Object.keys()`. За замовчанням `false`
    * `get` – функція, яка повертає значення властивості. За замовчанням не визначено
    * `set` – функція, яка записує значення властивості. За замовчанням не визначено
