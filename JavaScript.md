JavaScript
--
* `ECMAScript` – стандарт, а `JavaScript` – найпопулярніша реалізація цього стандарту
* `ES` — це просто скорочення для `ECMAScript`
* Кожне видання `ECMAScript` отримує абревіатуру `ES` з наступним номером
* Усього існує 8 версій `ECMAScript`
* `ES1` — було випущено у червні 1997 року
* `ES2` — у червні 1998 року
* `ES3` — у грудні 1999 року
* `ES4` — так і не було прийнято
* `ES5` — у грудні 2009 року
* `ES6` / `ES2015` — у червні 2015 року
  * `destructuring assignment`
  * `arrow function`
  * `let` / `const`
* `ES7` / `ES2016` — у червні 2016 року
  * `**`
  * `Array.prototype.includes`
* `ES8` / `ES2017` — у червні 2016 року
  * `async` /` await`
* `ES9` / `ES2018` — у червні 2016 року
  * `async` /` await` 

V8 Engine
--
* Це високопродуктивний рушій `JavaScript` і `WebAssembly` від `Google` з відкритим кодом, написаним на `C++`
* Використовується в `Node.js`
* `V8` транслює `JS`-код у більш ефективний машинний код, не використовуючи інтерпретатор

Методи HTTP запита
--
* `GET` — вимагає представлення ресурсу. Запити з цього методу можуть лише витягувати дані
* `HEAD` — просить ресурс так само як і метод `GET`, але без тіла відповіді
* `POST` — використовується для надсилання сутностей до певного ресурсу
* `PUT` — замінює всі поточні уявлення ресурсу даними запиту
* `DELETE` — видаляє вказаний ресурс
* `CONNECT` — встановлює "тунель" до сервера, визначеного ресурсом
* `OPTIONS` — використовується для опису параметрів з'єднання з ресурсом
* `TRACE` — виконує виклик тестового повідомлення, що повертається з ресурсу
* `PATCH` — використовується для часткової зміни ресурсу

Версії HTTP запита
--
* `HTTP/1.0` (1996)
  * Тільки якщо указано в заголовку `keep-alive`
  * Для завантаження кожного ресурсу встановлювалось нове TCP/IP з'єднання
* `HTTP/1.1` (2015)
  * Додані методи: `PUT`, `DELETE`, `OPTIONS`, `TRACE`, `CONNECT`, `PATCH`
  * Додано за замовчуванням `keep-alive`, який дозволив завантажувати безліч ресурсів у межах одного з'єднання. Однак, ресурси завантажуються послідовно `waterfall`: не можна отримати наступний ресурс, доки отримано попередній.
* `HTTP/2` (2015)
  * Застосування бінарного протоколу, що оперує передачею бінарних кадрів. Кожен кадр має заголовок з інформацією про тип, розмір, опції та ідентифікаторі потоку. Кадри з типом DATA використовуються для передачі даних, `HEADERS` — `HTTP`-заголовків, `RST_STREAM` — для дострокового переривання відправлення даних
  * Мультиплексування і розпаралелювання потоків в рамках одного `TCP` — з'єднання. Пакети різних потоків змішуються і, на відміну від конвеєрної передачі `HTTP/1.1`, не очікують закінчення відправлення запиту. Підтримка ефективної двобічної передачі даних. Можливість мультиплексування при зверненні до різних хостів, що дозволяє додатково прискорити одночасне завантаження вебконтенту з різних сайтів (у `SPDY` мультиплексування підтримується тільки для одного хоста)
  * Можливість встановлення пріоритетів і залежностей для потоків, що дозволяє виділити найважливіші потоки, які потрібно виконати в першу чергу, а також визначити залежність одного потоку від іншого
  * Стиснення `HTTP` — заголовків. У тому числі підтримується усунення дублікатів заголовків і Cookie, повторюваних для серії запитів до одного сайту. Допускається визначення окремих заголовків що не підлягають стисненню
  * Низька чутливість до затримок;
  * Засоби для узгодження протоколу між клієнтом і сервером, що дозволяють вибрати `HTTP/1.1`, `HTTP/2.0` і інші протоколи: сервер надає список підтримуваних протоколів, які може вибрати клієнт. Для шифрованих з'єднань параметри `TLS` узгоджуються за допомогою протоколу `ALPN`, при якому клієнт повідомляє список підтримуваних опцій, а сервер вибирає оптимальний для себе варіант
  * Забезпечення високого рівня сумісності з `HTTP/1.1`: збережені заголовки, схема `URI`, коди стану і методи (`GET`, `POST` тощо). Забезпечена можливість створення проксі для доступу клієнтів `HTTP/1.1` до серверів `HTTP/2.0`
  * Можливість встановлення шифрованих (`HTTPS`) і не шифрованих з'єднань (`HTTP`). Шифрування здійснюється з використанням `TLS 1.3` або новішої версії. Попри те, що специфікація дозволяє створення не шифрованих сполучень, розробники `Firefox` і `Google Chrome` мають намір забезпечити роботу `HTTP/2.0` тільки поверх `TLS`
  * Підтримка технології `Server Push` для передачі даних від сервера до клієнта (наприклад, коли сервер вважає, що після певного запиту обов'язково будуть потрібні інші дані, він може відправити ці дані не чекаючи фактичного запиту)
  * Підтримка `HTTP/2.0` на час пропозиції стандарту вже реалізована в браузерах
* `HTTP/3` (2018)
  * Це майбутня версія `HTTP`
  * `HTTP/3` базується на попередній чорновій версії `RFC` «Протокол передавання гіпертексту `HTTP` через `QUIC`
  * `QUIC` — це експериментальний мережевий протокол транспортного рівня, що спочатку розроблявся компанією `Google`, у якому керування транспортного затору простору користувача відбувається через протокол `User Datagram Protocol` (`UDP`).

Відповіді стану HTTP
--
  * `1xx` – інформаційні. Тимчасові коди, пов'язані з передачею даних, інформують про продовження прийнятого запиту.
  * `2xx` – успішні. Запит отримано та опрацьовано.
  * `3xx` – перенаправлення (редирект). Для виконання запиту необхідні ще дії.
  * `4xx` – клієнтські помилки. Запит не вдався через помилки клієнта.
  * `5xx` – серверні помилки. У цьому класі сервер завжди повідомляє про причини необробленого запиту. Клієнтської помилки в цьому випадку немає.
  * `200 OK` – Все добре
    * `201 Created` – «Створено». Запит виконаний і ресурс створений
    * `202 Accepted` – «Прийнято». Запит прийнятий, але не оброблений. Чи не підтримується – немає способу за допомогою `HTTP` відправити відповідь пізніше
    * `203 Non-Authoritative Information` – «Інформація не авторитетна». Повернута інформація надана з іншого джерела, а не від стартового сервера
    * `204 No Content` – «Немає вмісту». Немає вмісту для відповіді. Заголовки відповіді при цьому надсилаються
    * `205 Reset Content` – «Скинути вміст». Повідомлення, що запит оброблений, і необхідно відправити відображення документа цього запиту
    * `206 Partial Content` – «Частковий вміст». Використовується для окремого завантаження в кілька потоків при відправці заголовка діапазону
  * `301 Moved Permanently` – Редирект на нову сторінку на постійній основі, тобто сторінка переміщена на новий URL назавжди
    * `302 Found` – «Знайдено». Тимчасово змінено запитуваний ресурс. У майбутньому зміни в `URI`, можливо, будуть доступні
    * `303 See Other` – «Перегляд інших ресурсів». Напрямок для отримання запитуваного ресурсу в інший `URI` із запитом `GET`.
    * `304 Not Modified` – «Не модифіковано». Запитаний ресурс не змінений. Можна використовувати кешовану версію відповіді далі
    * `305 Use Proxy` – «Використовувати проксі». Запитуваний ресурс має доступ через проксі
    * `306 Switch Proxy` – «Більше не використовувати»
    * `307 Temporary Redirect` – «Тимчасове перенаправлення». Відправлено для отримання запитаного ресурсу на іншу `URL`-адресу за допомогою методу попереднього запиту
    * `308 Permanent Redirect` – «Перенаправлення на постійній основі». Постійне перебування ресурсу в іншому URI, який знаходиться в заголовку
  * `404 Not Found` – Сторінка не знайдена
    * `400 Bad Request` – «Поганий запит». Некоректний синтаксис не дає серверу обробити запит
    * `401 Unauthorized` – «Не авторизовано». Необхідна аутентифікація для отримання відповіді
    * `402 Required` – «Необхідна оплата». Код використання в майбутньому
    * `403 Forbidden` – «Заборонено». Сервер відмовляє у відповіді, бо у клієнта немає прав доступу до змісту ресурсу
    * `404 Not Found` – «Не знайдений». Сервер не може знайти запитуваний ресурс. Через частоти появи в інтернеті код відповіді є найвідомішим
    * `405 Method Not Allowed` – «Метод не дозволено». Метод, відомий серверу, деактивовано і неможливо його використовувати
    * `406 Not Acceptable` – Не знайдено контент із зазначеними критеріями від `user agent`
    * `407 Proxy Authentication Required` – Аналогічно коду `401`. Тільки в цьому коді потрібно аутентифікація для проксі сервера
    * `408 Request Timeout` – Відповідь коду може прийти без попереднього запиту, тому сервер відключає невикористовуване з'єднання
    * `409 Conflict` – Запит в конфлікті з реальним станом сервера
    * `410 Gone` – Контент, який був запитаний, видалено з сервера
    * `411 Length Required` – Серверу потрібен вказаний заголовок Content-Length, тому запит відхилений
    * `412 Precondition Failed` – У заголовках вказані умови, які серверу неможливо виконати
  * `500 Internal Server Error` — Внутрішня помилка сервера
    * `501 Not Implemented` – «Не виконано». Метод запиту не обробляється і не підтримується сервером
    * `502 Bad Gateway` – «Поганий шлюз». Під час роботи в якості шлюзу сервер отримав недійсну відповідь
    * `503 Service Unavailable` – «Сервіс недоступний». Сервер не готовий обробляти запит, причиною є відключення сервера або його перевантаженість. Сторінка повинна відправляти пояснення проблеми разом з відповіддю
    * `504 Gateway Timeout` – Сервер працює в вигляді шлюзу, не отримуючи своєчасно відповідь
    * `505 HTTP Version Not Supported` – «`HTTP`-версія не підтримується». Не підтримується `HTTP`-версія, яка використовується в запиті

CORS
--
* `Cross-Origin Resource Sharing` — Спільне використання ресурсів між різними джерелами — це система, що складається з відправки `HTTP` заголовків, які визначають: заблокувати або виконати запит до обмеженого ресурсу на вебсторінці з іншого домену, відмінного від домену походження запитуваного ресурсу

HTTP Cookie
--
* `HTTP cookie` (`web cookie`, `cookie` браузера) - це невеликий фрагмент даних, який сервер надсилає браузеру. Браузер може зберегти цей фрагмент у себе та відправляти на сервер з кожним наступним запитом. Це, зокрема, дозволяє дізнатися, чи з одного браузера надійшло кілька запитів (наприклад, для автентифікації користувача). За допомогою кук можна зберегти будь-яку інформацію про стан
  * `Session cookie` — Такі `cookie` видаляються під час закриття клієнта, тобто існують лише протягом поточного сеансу, оскільки атрибути `Expires` або `Max-Age` для нього не задаються
  * `Permanent cookies` — Видаляються не із закриттям клієнта, а при настанні певної дати (атрибут `Expires`) або після певного інтервалу часу (атрибут `Max-Age`)
  * `Secure` / `HttpOnly` — Куки надсилаються на сервер лише тоді, коли запит надсилається протоколом `SSL` і `HTTPS`
  * У технічному сенсі `cookies` – це невеликі за обсягом текстові файли. Максимально допустимий розмір одного такого файлу - `4096` байт

REST
--
* `REST` (`Representational State Transfer`) — це архітектурний стиль мережевої системи і виступає для передачі репрезентативного стану. Це сам не стандарт, але використовує такі стандарти, як `HTTP`, `URL`, `XML` і т.д. `REST` є архітектурним стилем, наразі `SOAP` є протоколом

"use strict"
--
* Директива `use strict` була новою в `ECMAScript` версії 5
  * Це не інструкція, а буквальний вираз, що ігнорується більш ранніми версіями `JavaScript`
  * Ціль `use strict` - вказати, що код має виконуватись в "строгому режимі"
  * В строгому режимі не можна, наприклад, використовувати не оголошені змінні, команди як `eval()` чи `this.caller`
  * У цьому режимі попередження `warning` стають помилками `error`

Immutable
--
* `Immutable` — Незмінне значення – це значення, зміст якого не можна змінити
* Примітивні значення незмінні (`string`, `number`, `bigint`, `boolean`, `undefined`, `symbol`, `null`) — коли примітивне значення створено, його неможливо змінити
* Значення `objects` і `arrays` є змінними за замовчуванням — їхні властивості та елементи можна змінювати
  * `let array = [1, 2, 3, 4, 5];`
  * `ImmutableArray = array.slice(0, -1);`
  * `array.push(6)` / `ImmutableArray = [...array, 6];`
  * `array.shift()` / `let = item; [item, ...ImmutableArray] = array;`
  * `array.unshift(5)` / `ImmutableArray = [5, ...array];`
  * `array.reverse()` / `ImmutableArray = [...array].reverse();`

`XSS` (`Cross-Site Scripting`)
--
* Один із різновидів атак на веб системи, що передбачає впровадження шкідливого коду на певну сторінку сайту та взаємодію цього коду з віддаленим сервером зловмисників при відкритті сторінки користувачем
* Основна мета `XSS`– крадіжка `cookies` користувачів за допомогою вбудованого на сервері скрипту з подальшою вибіркою необхідних даних та використанням їх для наступних атак та зломів

FAQ
--
* Які існують типи даних у `JS`?
  * Всього в `JavaScript` існує 8 типів
    * `number`
    * `string`
    * `boolean`
    * `bigint`
    * `null`
    * `undefined`
    * `symbol`
    * `object`
* Які значення в `JS` є хибними?
  * `0`
  * `null`
  * `undefined`
  * `NaN`
  * `false`
* Як перевірити, чи об’єкт є масивом?
  * Сучасний метод `array.isArray()` (був введений у стандарті `ECMAScript 5`)
  * Легасі `[1, 2].constructor.name === 'Array'`
  * Легасі `Object.prototype.toString.call([1, 2]) === '[object Array]'`
* Як перевірити, чи число є скінченним?
  * Глобальна `isFinite()` функція визначає, чи є передане значення кінцевим числом
* Як перевірити, що змінна рівна `NaN`? 
  * Функція `isNaN()` визначає чи є змінна нечисловим значенням `NaN` чи ні
* Чим відрізняється поведінка `isNaN()` та `Number.isNaN()`?
  * На відміну від глобальної функції `isNaN()`, `Number.isNaN()` немає проблеми примусового перетворення параметра в число. Це означає, що він безпечно передавати значення, які зазвичай перетворюються на `NaN`, але насправді `NaN` не є
* `JavaScript Hoisting`
  * `Hoisting` це процес, у якому інтерпретатор переміщує оголошення функцій, змінних або класів у верхню частину їхньої області видимості перед виконанням коду
* Порівняйте ключові слова `var`, `let`, `const`
  * `var`  
    * Значення може бути визначено пізніше
    * Значення може бути перевизначено в майбутньому
    * Підтримує повторне оголошення. Кількість оголошень не обмежена
    * Ігнорує блокову область видимості. Змінні, оголошені в такий спосіб будуть видно поза блоку
    * Підтримує `hoisting`
  * `let`
    * Значення може бути визначено пізніше
    * Значення може бути перевизначено в майбутньому
    * Не підтримують повторне оголошення
    * Дотримується блокової області видимості
    * Не підтримують `hoisting`
  * `const`
    * Значення має бути визначено під час оголошення змінної (відразу)
    * Значення у констант не перевизначаються
    * Не підтримують повторне оголошення
    * Дотримується блокової області видимості
    * Не підтримують `hoisting`
* Що таке область видимості?
  * Це частина коду, де змінні та функції можуть бути видимими та доступними для використання. Вона визначає, чи імена змінних і функцій є дійсними та можуть бути використані. У кожній області видимості певні змінні та функції можуть бути видимими, а інші можуть бути недоступними або мати інші значення
  * У JavaScript існує кілька типів областей видимості:
    * Глобальна область видимості
      * Вона охоплює всю програму. Змінні та функції, оголошені в глобальній області видимості, можуть бути доступні в будь-якому місці програми
    * Функціональна область видимості
      * Кожна функція в `JavaScript` має власну область видимості. Змінні, оголошені всередині функції, видно тільки всередині цієї функції, і вони не можуть бути доступні ззовні
    * Блокова область видимості
      * Запроваджено в `ECMAScript 6` за допомогою ключових слів `let` і `const`. Блокова область видимості обмежує видимість змінних тільки всередині блоку коду, який зазвичай визначається фігурними дужками `{}`. Змінні, оголошені всередині блоку, видно тільки всередині цього блоку і недоступні за його межами
   * Область видимості `eval`
* Що таке деструктуризація?
  * Деструктуризація об'єкта `JS` (`ECMAScript 2015` / `ES6`) – це синтаксична зручність, що полегшує вилучення даних із масивів або об'єктів, даючи змогу прямо “розпаковувати” їхні значення у змінні. Це дає змогу писати компактніший і виразніший код, зменшуючи необхідність вручну витягувати дані зі структур даних
* Для чого призначені методи setTimeout і setInterval?
  * `setTimeout` — дозволяє нам запускати функцію один раз через певний інтервал часу
    * `clearTimeout(id)` — використовувати для скасування виконання `setTimeout`
  * `setInterval` — дозволяє нам запускати функцію багаторазово, починаючи через певний інтервал часу, а потім постійно повторюючи у цьому інтервалі
    * `clearInterval(id)` — використовувати для скасування виконання `setInterval`
* Порівняйте підходи роботи з асинхронним кодом: `сallbacks` / `promises` / `async / await`
  * `сallback` — функція, що передається аргументом в іншу функцію для її виконання після завершення виконання певного коду. Така собі функція зворотного виклику. Відповідно функції, які використовуються для продовження роботи коду після виконання асинхронної операції є асинхронними колбеками
  * `promise` — це спеціальний об'єкт `JavaScript`, що використовується для написання та виконання асинхронного коду
  * `async / await` — Слово `async` додане до функції робить її асинхронною повертаючи результат у вигляді об'єкта `promise`, лишається зазначити через `await` на завершення якої частини коду ми хочемо почекати. По суті це синтаксичний цукор над `promise`.
* `Map` і `Set`
  * `Map` — це колекція ключ/значення, як і `Object`. Але основна відмінність полягає в тому, що `Map` дозволяє мати ключі будь-якого типу
    * Відмінності від звичайного об’єкта `Object`:
      * Що завгодно може бути ключем, в тому числі й об'єкти
      * Є додаткові методи, властивість `size`
  * `Set` – це особливий тип колекції: "множина" значень (без ключів), де кожне значення може з’являтися тільки раз
* Що означає глибока `deep` та поверхнева `shallow` копія об'єкта?
  * `shallow`
    * `Object.assign() / {...Object}` — Поверхнева копія скопіює лише `top-level` властивості, але вкладені об'єкти будуть використовуватися як оригіналом, так і копією
  * `deep`
    * `JSON.parse(JSON.stringify(Object)) / structuredClone()`
    * На жаль, цей метод не можна використовувати для копіювання методів об'єкта, написаних користувачем вручну
    * Не серіалізуються: примітив `undefined`, функція, `symbol` - при виклику JSON.stringify отримуємо `undefined`
* Яка різниця між декларацією функції `function declaration` та функціональним виразом `function expression`?
  * `Function Declaration`
    * Це функція яка має назву
  * `Function Expression`
    * Це функція яка присвоєна змінній
    * Може бути анонімною функцією
* Що таке анонімна функція?
  * Кожна функція `JavaScript` — це об'єкт [`Function`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
  * Функції бувають 
    * `Function Declaration`/ `Regular Function` — `function hello() { }`
    * `Function Expression` — `const hello = function() { }`
    * `Named Function Expression` — `const hello = function hello() { }`
    * `Arrow Function` — `const hello = () => { }`
    * `Auto Invoke Function` — `(function() { } ())` / `(() => { })()`
    * `Generator Function` — `function* generator(i) { yield i; yield i + 10; }`
* В чому полягають відмінності стрілкових функцій `arrow function` від звичайних?
  * Не може використовувати аргументи локальну змінну `arguments`, як у звичайних функціях `function hello() { console.log(arguments) }`
  * Не може використовувати як конструктори `constructor`
  * Не може можу бути типу `Function Declaration`
  * Не може використовуватись до того як була обʼявлена (не підтримують `hoisting`)
* `IIFE` (`Immediately Invoked Function Expression`)?
  * `IIFE` — це функція яка виконується відразу ж після того, як вона була визначена
  * Змінна, якій присвоєно `IIFE`, зберігає в собі результат виконання функцій, але не саму функцію
* Що таке `hoisting`?
  * `hoisting`, тобто спливання, підняття — це механізм, при якому змінні та оголошення функції піднімаються вгору по своїй області видимості перед виконанням коду
  * Дозволяє нам використовувати функції перед їх оголошенням у коді
* Що таке замикання `closure`?
  * `Сlosure` – поєднання функції, зчепленої вкупі з (замкненої на) посиланням на стан, що її оточує (лексичне оточення). Інакше кажучи, замикання надає з внутрішньої функції доступ до області видимості зовнішньої функції
  * У `JavaScript` замикання породжуються щоразу, коли створюється функція, під час її створення
* Що означає ключове слово `this`?
  * Для доступу до інформації всередині об’єкта метод може використовувати ключове слово `this`
  * Значення `this` визначається під час виконання
  * В такому випадку `this` є `undefined` в режимі `use strict`
  * В `use strict` режимі `this` є `undefined`, або `window` не в `use strict` режимі
  * Стрілкові функції `Arrow Function` не мають власного `this`, a якщо викликати `this` в середині `Arrow Function` то буде виклик зовнішнього `this`
* Методи функцій `bind` / `call` / `apply`
  * Метод `bind` створює нову функцію, яка при виклику встановлює в якості контексту виконання цього наданого значення
  * Метод `call` викликає функцію із вказаним значенням `this` та індивідуально наданими аргументами
  * Метод `apply` викликає функцію із вказаним значенням `this` і аргументами, наданими у вигляді масиву
* Що таке `DOM`?
  * `DOM` (`Document Object Model`) — це програмний інтерфейс `API`, який дає змогу розробникам отримувати доступ до структури та вмісту `HTML`
  * Деякі з ключових методів включають `DOM`
    * `getElementById(id)` — отримує елемент за його ідентифікатором
    * `getElementsByClassName(className)` — повертає колекцію елементів з певним класом
    * `getElementsByTagName(tagName)` — повертає колекцію елементів з певним тегом
    * `querySelector(selector)` — повертає перший елемент, що відповідає заданому селектору `CSS`
    * `querySelectorAll(selector)` — повертає всі елементи, що відповідають заданому селектору `CSS`
* Підключення скрипту `async` / `defer` в `HTML`
  * Атрибут `defer` повідомляє браузеру, що йому не треба чекати на скрипт. Замість цього браузер продовжить обробляти `HTML`, будувати `DOM`. Скрипт завантажується у фоновому режимі, а потім запускається, коли `DOM` повністю побудовано
    * Скрипти з `defer` ніколи не блокують сторінку
    * Скрипти з `defer` завжди виконуються, коли `DOM` готовий, але перед подією `DOMContentLoaded`
    * Відкладені скрипти зберігають відносний порядок, як і звичайні скрипти
    * Атрибут `defer` призначений лише для зовнішніх скриптів і ігнорується, якщо тег `<script>` не має `src`
  * Атрибут `async` дещо схожий на `defer`. Він також робить скрипт не блокуючим. Але він має важливі відмінності в поведінці
    * Браузер не блокує `async` скрипти
    * Інші скрипти не чекають `async` скриптів, а `async` скрипти не чекають їх
    * `DOMContentLoaded` та асинхронні скрипти не чекають один одного
    * Скрипти `async` завантажуються у фоновому режимі та запускаються по готовності
    * Атрибут `async` призначений лише для зовнішніх скриптів і ігнорується, якщо тег `<script>` не має `src`
* Яка різниця між властивостями `innerHTML` та `innerText`?
  * `innerHTML` — повертає текстовий вміст елемента, включаючи всі пробіли та внутрішні теги `HTML`
  * `innerText` повертає — лише текстовий вміст елемента та всіх його дочірніх елементів, без прихованих текстових інтервалів і тегів `CSS`, за винятком елементів `<script>` та `<style>`
* Бульбашковий механізм (спливання та занурення) `bubbles` / `capturing`
  * Спливання` bubbles`
    * Коли подія відбувається на елементі, спочатку запускаються обробники на ньому, потім на його батькові, потім на інших предках і так до самого верху
    * Найбільш глибоко вкладений елемент, що викликав подію, називається цільовим елементом, та доступний як `event.target`
    * `event.stopPropagation()` / `event.stopImmediatePropagation()` — зупиняє спливання
  * Занурення `capturing`
    * `element.addEventListener(..., { capture: true })` / `element.addEventListener(..., true)`
    * Фаза занурення `capturing phase` – подія "спускається" до елемента
    * Фаза цілі `target phase` – подія досягає цільового елемента
    * Фаза спливання `bubbling phase` – подія "спливає" від елемента вгору
* `sessionStorage`
  * `sessionStorage` дозволяє отримати доступ до об'єкта [`Storage`](https://developer.mozilla.org/en-US/docs/Web/API/Storage) поточної сесії
  * `sessionStorage` відчищаються в момент закінчення сесії поточної сторінки
  * Дані привʼязані до сайту Домен / Порт / Протокол
* `localStorage`
  * `localStorage` дозволяє отримати доступ до [`Storage`](https://developer.mozilla.org/en-US/docs/Web/API/Storage)  об'єкта зберігання
  * Не обмежені за часом зберігання та можуть бути видалені лише за допомогою `JavaScript`
  * Ключі та значення завжди `string`, так само як і об'єкти, ціло численні ключі будуть автоматично перетворені в `string`
  * Ліміт становить `5 Мб` і залежить від браузера
  * Спільний доступ з усіх вкладок і вікон для того самого сайту
  * Дані привʼязані до сайту Домен / Порт / Протокол
* `Event loop`
  * Потік виконання в `JavaScript` працює для розрахунку циклу подій `event loop`, який відповідає за виконання коду, збірку й обробку подій і виконання підзадач
  * Макрозадачі `Macrotasks` — `setTimeout`, `setImmediate`, `setInterval`, `UI`
  * Мікрозадачі `Microtasks` — `Promise`, `process.nextTick`, `queueMicrotask`, і на фронті ми маємо наглядача за DOM елементами — `MutationObserver`
  * Мікрозадачі мають пріоритет перед макрозадачами
  * Одразу після кожного макрозавдання, рушій виконує всі завдання з черги мікрозавдань перед тим як виконати якесь макрозавдання чи рендеринг, чи виконати щось іще
  * Жодні `UI` або мережеві події не обробляються між мікрозавданнями — мікрозавдання виконуються негайно одне за одним
  * Також обробники промісів виконуються в черзі мікрозавдань.
  * `FIFO` (`First In First Out`) — тобто остання подія буде оброблена в останню чергу
  * `process.nextTick()`
  * `queueMicrotask()`
  * `setImmediate()`
* `Temporal Dead Zone` / `TDZ`
  * `TDZ` — термін для опису стану, коли змінні недоступні. Вони в області видимості, але не оголошені. Тобто це проміжок часу між створенням зв'язування змінної `let` або `const` та її оголошенням (в межах її області)
  * Якщо `var` викликана до оголошення, то ця змінна матиме `undefined`
  * Якщо `let` або `const` викликана до оголошення, то ця цей код поверне помилку `ReferenceError: foo is not defined`
* `boxing-unboxing (Wrapper Objects)`
  * Не працює з `null` і `undefined`
  * `boxing-unboxing` — це процес тимчасового перетворення типу `string` в `object`, щоб можна було скористатися методом `toUpperCase`
* Що таке прототип `prototype`?
  * Може приймати значення `null` або мати посилання на інший `object`
  * `Object.getPrototypeOf` / `Object.setPrototypeOf` — це є `getter` / `setter`
  * Легасі `__proto__` — це є `getter` / `setter` для `[[Prototype]]`
  * Цикл `for..in` ітерує як і власні властивості, так і по успадковані
  * Методи `map` / `each` отримують з пар `key` / `value` тільки власні властивості об'єкта
* Що таке кортежі `tuples` і записи `records`?
  * `tuples` - це глибоко незмінні структури даних, подібні масивам. По суті, це складні примітивні типи, ідентифіковані модифікатором `#` перед синтаксисом нормального масиву `const foo = #[1, 2, 3];` / `const foo = Tulpe.from([1, 2, 3]);`
    * Не повинно бути` holes` з невстановленими значеннями. Наприклад, `#[1, , ,4]` недійсний
    * Повинні мати лише примітиви, інші кортежі `tuples` чи записи `records`
    * Оскільки кортежі `tuples` є примітивами, їх можна порівняти за значенням з іншими кортежами `const foo = #[1, 2, 3]; foo === #[1, 2, 3];`
    * Якщо кортеж `tuples` має одне значення, його можна зрівнювати не строгим порівнянням `==`, наприклад: `const foo = #[123]; foo == #[123]; foo == 123; foo == '123'`
  * `records` - це глибоко незмінні структури даних подібні об'єктам `const foo = #{ foo: 123 }` / `const foo = new Record({ foo: 123 });`
    * Повинні мати лише примітиви, інші кортежі `tuples`, записи `records` чи примітиви
    * Оскільки записи `records` є примітивами, їх можна порівняти за значенням з іншими записами `const foo = #{ 1, 2, 3 }; foo === #{ 1, 2, 3 };`
* Які відмінності в поведінці `ES5` функції-конструктора та `ES2015` класу?
  * Клас — це синтаксичний цукор над функцією конструктора
  * Під час створення екземпляра класу, методи описані в ньому потрапляють у прототип, а методи описані всередині функції конструктора потраплять у сам екземпляр
  * Для того, щоб методи, описані всередині функції конструктора, потрапили в прототип, їх потрібно окремо туди додати
* Що таке приведення (перетворення) типів у `JS`?
  * Приведення типів `Coercion` це процес перетворення значення з одного примітивного типу в інший
  * Наприклад, `JavaScript` може перетворити число в рядок, або не-логічне (не-булеве) значення в логічне
* Що таке `Garbage Collector`?
  * Управління пам'яттю `JavaScript` виконується автоматично і непомітно для нас
  * Основною концепцією управління пам'яттю `JavaScript` є принцип досяжності
  * Досяжними вважаються ті, що доступні або використовуються. Вони гарантовано перебувають у пам'яті
  * Щоб об'єкт став не досяжним, потрібно видалити на нього всі посилання, після того, як він стане не досяжним, він піти з пам'яті
* Опишіть призначення і принципи роботи з колекціями `WeakMap` і `WeakSet`
  * `WeakMap`
    * Перша відмінність між `Map` та `WeakMap` – це те, що ключі повинні бути об'єктами, а не примітивними значеннями
    * `WeakMap` – це подібна до Map колекція, яка дозволяє використовувати лише об'єкти, як ключі й видаляє їх разом з пов'язаним значенням, коли вони стануть недоступними іншим засобам
  * `WeakSet`
    * Перша відмінність між `Set` та `WeakSet` – це те, що ключі повинні бути об'єктами, а не примітивними значеннями
    * `WeakSet` – це подібна до `Set` колекції, яка зберігає тільки об'єкти та видаляє їх після того, як вони стануть недоступними іншим засобам
  * Їх основна перевага полягає у тому, що вони мають слабке посилання на об'єкти, тому вони можуть бути легко видаленими збирачем сміття
  * Це досягається внаслідок відсутності підтримки `clear`, `size`, `keys`, `values`
  * WeakMap та WeakSet використовуються як "вторинні" структури даних, на додаток до "первинного" сховища об'єктів
  * Після того, як об'єкт видаляється з первинного сховища, якщо він виявляється лише як ключ `WeakMap` або в `WeakSet`, він буде очищений автоматично
* Чим відрізняється `Observable` від `Promise`?
  * `Observable`
    * Більш гнучка система керування подіями й потоками даних
    * Можливість створювати складні послідовності подій
    * Легше взаємодіяти з даними з різних джерел
  * `Promise`
    * Простіший та більш інтуїтивний синтаксис
    * Зручний для обробки одиничних асинхронних операцій
* `Web workers`
  * `new Worker('worker.js')` — Після створення web-worker він працює в окремому потоці, незалежному від основного потоку браузера, виконуючи будь-який код у наданому йому скрипті
  * Дані між `Workers` та основним потоком JavaScript передаються за допомогою двох додаткових функцій у коді `JavaScript` функція `postMessage()` для посилання даних
  * Ізольоване глобальне середовище для потоку web worker, окреме від середовища браузера
  * Обмін даними через основний потік та потік `web worker` відбувається тільки через виклик `postMessage()`, причому дані передаються за значенням
  * Можливі випадки застосування `web worker`
    * Попереднє завантаження та / або кешування даних для подальшого використання
    * Опитування та обробка даних із вебслужб
    * Обробка та показ великих наборів даних `think genomics`
    * Обчислення, пов'язані з рухами в грі
    * Обробка та фільтрація зображень
    * Обробка текстових даних (синтаксис коду, перевірка правопису, кількість слів)
* Що таке `ArrayBuffer`? У чому різниця між `Uint32Array` і `Float32Array`?
  * `ArrayBuffer` використовується для роботи з бінарними даними, не є масивом
  * Він має фіксовану довжину, що не може бути збільшена чи зменшена
  * Він займає саме стільки місця, скільки виділено при створенні
  * Для доступу до окремих байтів нам знадобиться окремий об’єкт представлення, `buffer[index]` не спрацює
  * Він являти собою посилання на потік "сирих" подвійних даних, однак працювати з ними прямої можливості не дає
  * Для роботи з `ArrayBuffer` нам потрібен спеціальний об'єкт "представлення"
    * `Uint8Array` – представляє кожен байт в `ArrayBuffer` окремому числом з областю значень від 0 до 255 (байт складається з 8 біт, тому тільки такі значення можливі). Такі числа називаються "8-бітові беззнакові цілі числа"
    * `Uint16Array` – представляє кожні 2 байти цілим числом з областю значень від 0 до 65535. Має назву "16-бітові беззнакові цілі числа"
    * `Uint32Array` – представляє кожні 4 байти цілим числом з областю значень від 0 до 4294967295. Має назву "32-бітові беззнакові цілі числа"
    * `Float64Array` – представляє кожні 8 байтів числом з плаваючою комою з областю значень від 5.0x10-324 до 1.8x10308
    * Отже, бінарні дані в 16 байтному `ArrayBuffer` можна представити як 16 "коротких чисел" або 8 більших чисел (2 байти кожне), або 4 ще більших (4 байти кожне), або 2 числа з плаваючою комою високої точності (8 байти кожне)
* Що таке `descriptor`?
  * Дескриптор `descriptor` – об'єкт, який описує властивості поведінки
    * `value` – значення властивості, за замовчанням `undefined`
      *  Щоб уникнути конфлікту, заборонено одночасно показувати значення `value` та функції `get` / `set`
      * Також заборонено і не має сенсу вказувати можливість запису при наявності функцій `get` / `set`
    * `writable` – значення властивості можна змінювати, якщо `true`. За замовчанням `false`.
    * `configurable` – якщо true, це властивість можна видалити, а також змінити його надалі за допомогою нових викликів `defineProperty`. За замовчанням `false`
    * `enumerable` – якщо істина, це властивість переглядається в циклі `for..in` і методі `Object.keys()`. За замовчанням `false`
    * `get` – функція, яка повертає значення властивості. За замовчанням не визначено
    * `set` – функція, яка записує значення властивості. За замовчанням не визначено
