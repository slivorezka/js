* `React` — це `JavaScript` — бібліотека для розробки інтерфейсу користувача
* Що таке `DOM`, `Virtual DOM` та `Shadow DOM`?
    * `DOM` (`Document Object Model`)
      * Це `API` сторінки, що дозволяє читати та маніпулювати вмістом.
    * `Virtual DOM`
      * `Virtual DOM` створений, щоб постійне оновлення `DOM` стало більш продуктивним
      * `Virtual DOM` — інструмент, що дозволяє взаємодіяти з елементами `DOM` простіше та ефективніше. 
      * `Virtual DOM` представлено у вигляді об'єкта `JavaScript`, який ми можемо змінювати так часто, як нам потрібно
      * На відміну від звичайного `DOM` та `Shadow DOM`, `Virtual DOM` — не є офіційна специфікація, а скоріше новий метод взаємодії з `DOM`
    * `Shadow DOM`
      * `Shadow DOM` - це браузерна технологія, призначена, головним чином, для визначення області видимості змінних та `CSS` у вебкомпонентах
      * `Shadow DOM` використовується для інкапсуляції. Він дозволяє компоненті мати своє власне "тіньове" `DOM`-дерево, що не може бути випадково змінено з головного документу, а також може мати власні локальні стилі, та інше
      * `Shadow DOM` – це спосіб створити ізольоване `DOM`-дерево для компонента
      * `shadowRoot = elem.attachShadow({mode: open|closed})` – створює тіньовий `DOM` для `elem`. Якщо `mode="open"`, то він є досяжним як властивість `elem.shadowRoot`
      * Ми можемо записати щось всередину `shadowRoot`, використовуючи `innerHTML` чи інші `DOM`-методи
      * Мають окрему область для унікальності значень в атрибутах `id` `HTML`-елементів
      * Невидимі для селекторів `JavaScript` з головного документу, таким методам, як `querySelector`
      * Використовують стилі тільки з тіньового дерева, а не глобальні стилі документа.
* Навіщо потрібний атрибут `crossorigin`?
  * Така практика дозволить покращити обробку помилок у `React 16` та новіших версіях
* Що таке `Context` у `React`?
  * `Context` розроблено для передачі даних, які можна назвати «глобальними» для всього дерева `React`-компонентів
  * Використовується для передачі інформації про минаючи пропси
  * `React` автоматично ререндерить компонети які використовують `сontext`
* Особливості `JSX`?
  * Запобігає атакам `XSS`, заснованим на ін'єкції коду
  * Є об'єктами, оскільки при компіляції `Babel` компілює `JSX` у виклики `React.createElement`
  * Можна використовувати силу `JS` прямо у компонентах
  * У `React` розмітці не можна запобігти обробці події за замовчанням, повернувши `false`. Потрібно явно викликати `preventDefault` у об'єкта події функції
  * `JSX`-тип не може бути виразом `<Components[props.storyType] />` Помилка!
  * Обхідний шлях: `const SpecificStory = Components[props.storyType] return <SpecificStory />`
  * `JSX` видаляє порожні рядки та пробіли на початку та в кінці рядка
* У чому різниця між елементами та компонентами?
  * Елементи — це те, «з чого зроблено» компоненти
  * Компоненти це спосіб реалізації коду таким чином, щоб його можна було перевикористовувати
* Як оновлюються елементи на сторінці?
  * Елементи `React` є іммутабельними. Після створення елемента не можна змінити його нащадків чи атрибути
  * Єдиний спосіб оновити елемент – це наново його відрендерити
* Що таке ключі та навіщо вони потрібні?
  * Ключі це помічники будь-якого списку, які служать ідентифікатором елемента
  * Вони допомагають `React` визначати, які елементи були змінені, додані чи видалені. Таким чином, `React` не буде заново оновлювати елементи, які не змінилися
* Що таке бандлінг?
  * Це процес виявлення імпортованих файлів та об'єднання їх в один «зібраний» файл
* Що таке компонент вищого порядку `HOC` (`Higher Order Component`)
  * Функція, яка приймає компонент і повертає новий компонент називається `HOC`, це один із просунутих способів для повторного використання логіки
  * `HOC` можна використовувати як обгортку компонентів, додаючи до них загальну функціональність
  * `HOC` виконуються під час створення компонента і логіка, додана `HOC`, застосовується при кожному рендері
  * `HOC` має доступ до життєвих циклів компонента та його стану
  * Мінус `HOC` у тому, що він створює нову `node` (елемент у дереві `DOM`) перед компонентом
* Чим відрізняється `React.PureComponent` від `React.Component`?
  * У `React.Component` при зміні значення або пропсу одразу відбувається оновлення, не дивлячись на минуле значення
  * У `React.PureComponent` йде поверхневе порівняння (`shallowEqual`) минулого значення і нового, і від результату залежить чи буде компонент ре-рендеретися
* Що таке `Render Props Components`
  * Компонент з рендер-пропсами — це компонент, який приймає функцію як властивість і викликає цю функцію для рендерингу будь-чого
  * Компонент із рендер-пропсами дозволяє передавати логіку рендерингу безпосередньо в компонент, який використовує цей компонент із рендер-пропсами
  * Логіка рендерингу передається через функцію-пропс і може бути використана за потреби
  * Компонент із рендер-пропсами не має доступу до життєвих циклів батьківського компонента, але може мати доступ до стану через пропси
  * Приклад компонента з рендер-пропсами — компонент `Mouse` або `Toggle` в документації `React`
* Що таке хуки `hooks`?
  * Хуки – нововведення у `React 16.8`, яке дозволяє використовувати стан та інші можливості `React` без написання класів
  * Це функції, за допомогою яких ви можете «підчепитися» до стану та методів життєвого циклу `React` із функціональних компонентів
  * Хуки слід викликати тільки на найвищому рівні. Не викликайте хуки всередині циклів, умов або вкладених функцій
  * Хуки слід викликати тільки з функційних `React`-компонентів. Не викликайте хуки зі звичайних функцій `JavaScript`
  * `useState`
    * `useState` — `React` буде зберігати цей стан між повторними рендерами
    * Виклик `useState` повертає дві речі: поточне значення стану та функцію, яка дозволяє оновлювати цей стан
    * Єдиним аргументом для `useState` є початкове значення стану
  * `useEffect`
    * За допомогою хука ефекту `useEffect` ви можете виконувати побічні ефекти із функційного компонента
    * Він виконує таку ж саму роль, що і `componentDidMount`, `componentDidUpdate` та `componentWillUnmount` у `React`-класах
  * `useContext`
  * `useReducer` 
    * Є альтернативою `useState`. Приймає редюсер типу (`state`, `action`) => `newState` і повертає поточний стан у парі з методом `dispatch`
    * Слід віддати перевагу `useReducer` над `useState`, коли ви маєте складну логіку стану, що включає багато значень чи ваш наступний стан залежить від попереднього
    * Крім того, `useReducer` дозволяє вам оптимізувати продуктивність для компонентів, що викликають глибокі оновлення
  * `useCallback`
  * `useRef`
    * `useRef` поверне змінний об’єкт рефу, властивість `.current` якого ініціалізується переданим аргументом (`initialValue`)
    * Повернутий об'єкт буде зберігатись протягом всього часу життя компонента.
  * `useImperativeHandle`
    * `useImperativeHandle` налаштовує значення екземпляра, яке надається батьківським компонентам при використанні `ref`
  * `useLayoutEffect`
    * Сигнатура хука є ідентичною `useEffect`, але він запускається синхронно після всіх змін `DOM`
    * Використовуйте це для читання розмітки з `DOM` і синхронних повторних рендерів. Оновлення, заплановані всередині `useLayoutEffect`, будуть виконані синхронно перед тим, як браузер відобразить їх
  * `useDebugValue`
    * `useDebugValue` може бути використаний для відображення мітки користувацьких хуків у інструментах розробника `React`
  * 
* Поясніть методи життєвого циклу компонентів `React`
  * `render` — єдиний обов'язковий метод у класовому компоненті. Під час виклику він перевіряє `this.props` і `this.state` і повертає один з наступних варіантів: Елемент `React`, Масиви та фрагменти, Портали, Рядки та числа, `Booleans` або `null` 
  * `componentWillMount()` - виконується перед рендерингом як на клієнті, так і на сервері
  * `componentDidMount()` - виконується лише на клієнті після першого рендерингу
  * `componentWillUnmount()` - викликається після розмонтування компонента з `DOM`. Використовується для чищення пам'яті.
  * `componentWillReceiveProps()` - викликається до того, як змонтований компонент отримає нові пропси
  * `shouldComponentUpdate()` - повертає `true` чи `false` залежно від певних умов. Якщо ви хочете оновити компонент, поверніть `true`, інакше поверніть `false`
  * `componentWillUpdate()` - викликається перед відображенням у `DOM`
  * `componentDidUpdate()` - викликається відразу після рендеру
* У чому різниця між `controlled` і `uncontrolled` компонентами?
  * Контрольований компонент `controlled` – це такий компонент, де `React` здійснює контроль і є єдиним джерелом правди для даних форми (наприклад, за допомогою хуків)
  * Некотрольований компонент `uncontrolled` - це такий компонент, де ваші дані форми обробляються в `DOM`, а не всередині вашого компонента (прямо в `jsx`)
* Що таке `Reconciliation`?
  * Це процес, за допомогою якого `React` оновлює `DOM`
* `React Fiber`?
  * `React Fiber` – це реалізація основного алгоритму `React`
  * Його головною особливістю є інкрементний рендеринг: можливість розділити роботу рендерингу на шматки та розподілити їх за кількома кадрами
  * Включають можливість зупиняти, переривати або повторно використовувати роботу з надходженням нових оновлень
  * Можливість призначати пріоритет різним типам оновлень
  * Нові примітиви паралелізму
* `Redux` — відкрита `JavaScript` бібліотека призначена для керування станом програм `JavaScript`
  * Існує єдине джерело істини для всього вашого стану програми
  * Цей стан тільки для читання (`read-only`)
  * Всі зміни в стан застосунку вносяться за допомогою чистих функцій
* Робота зі стилями в `React`
  * Таблиця стилів `CSS`
    * `import './App.css';`
  * Вбудований стиль (Інлайнова стилізація `React` компонентів)
    *  `<div style={{ backgroundColor: "#FFF", width: "300px", minHeight: "200px"}}>`
  * `Styled Components`
    * `import styled from 'styled-components';`
    * `const ErrorMessage = styled.p" color: white; font-size: 13px;"`;
  * `CSS` Модулі
    * `import styles from "./styles.module.css";`
    * `<p className = {styles.error-message}>I am an error message</p>`
* Що таке `codemod`?
  * `Codemod` написано на `Python`
  * `Codemod` – це інструмент, розроблений Facebook для рефакторингу великих кодових баз
  * Він дозволяє розробнику реорганізувати великий обсяг коду за невеликий проміжок часу
* Що таке портали у `React`?
  * Портали дозволяють рендерити дочірні елементи в `DOM`-вузол, що знаходиться поза `DOM`-ієрархією батьківського компонента
  * `ReactDOM.createPortal(child, container)`
* Що таке `Flux`
  * 
* Що таке "Підйом стану" `Lifting state up`?
  * "Підйом стану" `Lifting state up` - це патерн в `React`, який передбачає переміщення стану з дочірніх компонентів до батьківських компонентів, щоб розділяти та керувати станом на вищому рівні та передавати його через пропси.
  * Цей підхід особливо корисний, коли кілька компонентів повинні мати доступ до того самого стану або коли стан має бути синхронізований між різними частинами програми.
* Що таке фрагменти `fragments` в `React`?
  * Фрагменти `fragments` - це механізм `React`, який дозволяє вам групувати дочірні елементи без необхідності створювати зайві `DOM`-елементи
  * Вони дозволяють повернути кілька елементів з компонента без обертання їх у додатковий `DOM`-контейнер
  * Фрагменти можуть бути оголошені за допомогою порожніх `<>` і `</>`, а всередині них можна розміщувати будь-яку кількість дочірніх елементів
* Що таке рефи `refs` у `React` і як вони використовуються?
  * `Refs` (скорочення від `references`) - це механізм `React`, що дозволяє отримувати прямий доступ до `DOM` елементів чи компонентів, створеним `React`
  * Вони дозволяють вам звертатися до елементів, оновлювати їх властивості та викликати методи компонентів без використання пропсів чи стану
  * `Refs` корисні, коли вам потрібно взаємодіяти з `DOM` елементами безпосередньо або отримати доступ до методів і властивостей компонентів, які не доступні через пропси
* 
* `props drilling` - коли дані проходять кілька рівнів вкладеності, що ускладнює управління та контроль стану
