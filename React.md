* `React` — це `JavaScript` — бібліотека для розробки інтерфейсу користувача
* Що таке `DOM`, `Virtual DOM` та `Shadow DOM`?
    * `DOM` (`Document Object Model`)
      * Це `API` сторінки, що дозволяє читати та маніпулювати вмістом.
    * `Virtual DOM`
      * `Virtual DOM` створений, щоб постійне оновлення `DOM` стало більш продуктивним
      * `Virtual DOM` — інструмент, що дозволяє взаємодіяти з елементами `DOM` простіше та ефективніше. 
      * `Virtual DOM` представлено у вигляді об'єкта `JavaScript`, який ми можемо змінювати так часто, як нам потрібно
      * На відміну від звичайного `DOM` та `Shadow DOM`, `Virtual DOM` — не є офіційна специфікація, а скоріше новий метод взаємодії з `DOM`
    * `Shadow DOM`
      * `Shadow DOM` - це браузерна технологія, призначена, головним чином, для визначення області видимості змінних та `CSS` у вебкомпонентах
      * `Shadow DOM` використовується для інкапсуляції. Він дозволяє компоненті мати своє власне "тіньове" `DOM`-дерево, що не може бути випадково змінено з головного документу, а також може мати власні локальні стилі, та інше
      * `Shadow DOM` – це спосіб створити ізольоване `DOM`-дерево для компонента
      * `shadowRoot = elem.attachShadow({mode: open|closed})` – створює тіньовий `DOM` для `elem`. Якщо `mode="open"`, то він є досяжним як властивість `elem.shadowRoot`
      * Ми можемо записати щось всередину `shadowRoot`, використовуючи `innerHTML` чи інші `DOM`-методи
      * Мають окрему область для унікальності значень в атрибутах `id` `HTML`-елементів
      * Невидимі для селекторів `JavaScript` з головного документу, таким методам, як `querySelector`
      * Використовують стилі тільки з тіньового дерева, а не глобальні стилі документа.
* Навіщо потрібний атрибут `crossorigin`?
  * Така практика дозволить покращити обробку помилок у `React 16` та новіших версіях
* Особливості `JSX`?
  * Запобігає атакам `XSS`, заснованим на ін'єкції коду
  * Є об'єктами, оскільки при компіляції Babel компілює `JSX` у виклики `React.createElement`
  * Можна використовувати силу `JS` прямо у компонентах
  * У React розмітці не можна запобігти обробці події за замовчанням, повернувши `false`. Потрібно явно викликати `preventDefault` у об'єкта події функції
  * `JSX`-тип не може бути виразом `<Components[props.storyType] />` Помилка!
  * Обхідний шлях: `const SpecificStory = Components[props.storyType] return <SpecificStory />`
  * `JSX` видаляє порожні рядки та пробіли на початку та в кінці рядка
* У чому різниця між елементами та компонентами?
  * Елементи — це те, «з чого зроблено» компоненти
  * Компоненти це спосіб реалізації коду таким чином, щоб його можна було перевикористовувати
* Як оновлення елементів на сторінці?
  * Елементи `React` є іммутабельними. Після створення елемента не можна змінити його нащадків чи атрибути
  * Єдиний спосіб оновити елемент – це наново його відрендерити
* Що таке ключі та навіщо вони потрібні?
  * Ключі це помічники будь-якого списку, які служать ідентифікатором елемента
  * Вони допомагають `React` визначати, які елементи були змінені, додані чи видалені. Таким чином, `React` не буде заново оновлювати елементи, які не змінилися
* Що таке бандлінг?
  * Це процес виявлення імпортованих файлів та об'єднання їх в один «зібраний» файл
* Що таке компонент вищого порядку `HOC`
  * Функція, яка приймає компонент і повертає новий компонент називається `HOC`, це один із просунутих способів для повторного використання логіки
  * Мінус `HOC` у тому, що він створює нову `node` (елемент у дереві `DOM`) перед компонентом
* Чим відрізняється `React.PureComponent` від `React.Component`?
  * У `React.Component` при зміні значення або пропсу одразу відбувається оновлення, не дивлячись на минуле значення
  * У `React.PureComponent` йде поверхневе порівняння (`shallowEqual`) минулого значення і нового, і від результату залежить чи буде компонент ре-рендеруватися
* Що таке хуки `hooks`?
  * Це функції, за допомогою яких ви можете «підчепитися» до стану та методів життєвого циклу `React` із функціональних компонентів
* Поясніть методи життєвого циклу компонентів `React`
  * `componentWillMount()` - виконується перед рендерингом як на клієнті, так і на сервері
  * `componentDidMount()` - виконується лише на клієнті після першого рендерингу
  * `componentWillReceiveProps()` - викликається до того, як змонтований компонент отримає нові пропси
  * `shouldComponentUpdate()` - повертає `true` чи `false` залежно від певних умов. Якщо ви хочете оновити компонент, поверніть `true`, інакше поверніть `false`
  * `componentWillUpdate()` - викликається перед відображенням у `DOM`
  * `componentDidUpdate()` - викликається відразу після рендеру
  * `componentWillUnmount()` - викликається після розмонтування компонента з `DOM`. Використовується для чищення пам'яті.
* У чому різниця між `controlled` і `uncontrolled` компонентами?
  * Контрольований компонент `controlled` – це такий компонент, де `React` здійснює контроль і є єдиним джерелом правди для даних форми (наприклад, за допомогою хуків)
  * Некотрольований компонент `uncontrolled` - це такий компонент, де ваші дані форми обробляються в `DOM`, а не всередині вашого компонента (прямо в `jsx`)
* Що таке `Reconciliation`?
  * Це процес, за допомогою якого `React` оновлює `DOM`
* `React Fiber`?
  * `React Fiber` – це реалізація основного алгоритму `React`
  * Його головною особливістю є інкрементний рендеринг: можливість розділити роботу рендерингу на шматки та розподілити їх за кількома кадрами
  * Включають можливість зупиняти, переривати або повторно використовувати роботу з надходженням нових оновлень
  * Можливість призначати пріоритет різним типам оновлень
  * Нові примітиви паралелізму
* `Redux` — відкрита `JavaScript` бібліотека призначена для керування станом програм `JavaScript`
  * Існує єдине джерело істини для всього вашого стану програми
  * Цей стан тільки для читання (`read-only`)
  * Всі зміни в стан застосунку вносяться за допомогою чистих функцій
* Робота зі стилями в React
  * Таблиця стилів CSS
    * `import './App.css';`
  * Вбудований стиль (Інлайнова стилізація `React` компонентів)
    *  `<div style={{ backgroundColor: "#FFF", width: "300px", minHeight: "200px"}}>`
  * `Styled Components`
    * `import styled from 'styled-components';`
    * `const ErrorMessage = styled.p" color: white; font-size: 13px;"`;
  * `CSS` Модулі
    * `import styles from "./styles.module.css";`
    * `<p className = {styles.error-message}>I am an error message</p>`
* Що таке `codemod`?
  * `Codemod` написано на `Python`
  * `Codemod` – це інструмент, розроблений Facebook для рефакторингу великих кодових баз
  * Він дозволяє розробнику реорганізувати великий обсяг коду за невеликий проміжок часу
